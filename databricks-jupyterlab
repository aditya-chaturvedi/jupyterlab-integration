#!/usr/bin/env python

#   Copyright 2019 Bernhard Walter
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

import argparse
import base64
import json
import os
import sys
import uuid
from getpass import getpass
from subprocess import check_output
from enum import Enum

import pyperclip

import jupyter_core.command

import databricks_jupyterlab
from databricks_jupyterlab.remote import (get_db_config, get_cluster, connect,
                                          prepare_ssh_config, check_installed,
                                          get_remote_packages, is_reachable,
                                          create_kernelspec, install_libs,
                                          mount_sshfs, show_profiles, bye)


def conda_version():
    try:
        result = check_output(["conda", "--version"])
    except Exception as ex:
        print(ex)
        print("conda cannot be called. Is it properly installed?")
        sys.exit(1)

    result = result.strip().decode()
    return tuple([int(v) for v in result.split(" ")[1].split(".")])


def write_config():
    config = {
        "c.KernelManager.autorestart": False,
        "c.MappingKernelManager.kernel_info_timeout": 120
    }

    config_file = os.path.expanduser("~/.jupyter/jupyter_notebook_config.py")
    if os.path.exists(config_file):
        with open(config_file, "r") as fd:
            lines = fd.read().split("\n")

        with open(config_file, "w") as fd:
            for line in lines:
                kv = line.strip().split("=")
                if len(kv) == 2:
                    k, v = kv
                    if config.get(k, None) is not None:
                        fd.write("%s=%s\n" % (k, config[k]))
                        del config[k]
                    else:
                        fd.write("%s\n" % line)
            for k, v in config.items():
                fd.write("%s=%s\n" % (k, v))
    else:
        with open(config_file, "w") as fd:
            fd.write("\n".join(["%s=%s" % (k, v) for k, v in config.items()]))


def version_check():
    packages = json.loads(check_output(["conda", "list", "--json"]))
    deps = {p["name"]: p["version"] for p in packages}

    remote_packages = get_remote_packages(cluster_id)
    remote_deps = {p["name"]: p["version"] for p in remote_packages}
    joint_keys = sorted(list(set(list(deps.keys()) + list(remote_deps.keys()))))
    print("%-30s %-10s%-10s" % ("Package", "local", "remote"))
    if str(args.versioncheck) == "all":
        scope = joint_keys
    elif str(args.versioncheck) == "same":
        scope = [
            key for key in joint_keys
            if deps.get(key, None) == remote_deps.get(key, None)
        ]
    else:
        scope = [
            key for key in joint_keys
            if deps.get(key, None) != remote_deps.get(key, None) and
            deps.get(key, None) is not None and
            remote_deps.get(key, None) is not None
        ]
    for key in scope:
        if deps.get(key) == remote_deps.get(key):
            print('\033[92m', end="")
        else:
            print('\033[91m', end="")
        print("%-30s %-10s  %-10s" %
              (key, deps.get(key, "--"), remote_deps.get(key, "--")))
        print('\033[0m', end="")


class VCheck(Enum):
    a = 'all'
    d = 'diff'
    s = 'same'

    def __str__(self):
        return self.value


parser = argparse.ArgumentParser(
    description='Configure remote Databricks access with Jupyter Lab')

parser.add_argument('profile',
                    nargs='?',
                    type=str,
                    default="",
                    help='A databricks-cli profile')
parser.add_argument('-c',
                    '--clipboard',
                    dest='clipboard',
                    action='store_true',
                    help='Copy the personal access token to the clipboard')
parser.add_argument('-i',
                    '--id',
                    dest='cluster_id',
                    help='The cluster_id to avoid manual selection')
parser.add_argument('-k',
                    '--kernelspec',
                    dest='kernelspec',
                    action='store_true',
                    help='Create a kernel specification')
parser.add_argument('-o',
                    '--organisation',
                    dest='organisation',
                    help='The organisation for Azure Databricks')
parser.add_argument('-p',
                    '--profiles',
                    dest='profiles',
                    action='store_true',
                    help='Show all datbricks cli profiles and check SSH key')
parser.add_argument('-r',
                    '--restart',
                    dest='restart',
                    action='store_true',
                    help='Restart cluster with id cluster_id')
parser.add_argument('-s',
                    '--sshfs',
                    dest='sshfs',
                    action='store_true',
                    help='Mount remote filesystem via sshfs')
parser.add_argument('-v',
                    '--versioncheck',
                    dest='versioncheck',
                    type=VCheck,
                    choices=list(VCheck),
                    help='Check version of local env with remote env')

args = parser.parse_args()
profile = args.profile

version = conda_version()
if version[1] >= 4 and version[2] >= 5:
    print("Valid version of conda detected: %s.%s.%s" % version)
else:
    print("Too old conda version:")
    print("Please update conda to at least 4.7.5")
    sys.exit(1)

module_path = os.path.dirname(databricks_jupyterlab.__file__)
if args.profile == "" and not args.profiles:
    parser.print_help()
    print(
        "\ndatabricks-jupyterlab: error: the following arguments are required: profile\n"
    )
    sys.exit(1)

if not args.profiles:
    print("\n* Getting host and token from .databrickscfg")
    host, token = get_db_config(profile)

if args.clipboard:
    pyperclip.copy(token)
    print("   => Personal access token copied to clipboard")

started = False
if args.kernelspec or args.restart or args.sshfs or args.versioncheck:
    print("\n* Select remote cluster")
    apiclient = connect(profile)
    cluster_id, public_ip, cluster_name, started, status_file = get_cluster(
        apiclient, profile, host, token, args.cluster_id)
    if cluster_name is None:
        print("Error: cluster_id '%s' not found" % cluster_id)
        sys.exit(1)

    print("\n* Configuring ssh config for remote cluster")
    status_file.log_ssh()
    prepare_ssh_config(cluster_id, profile, public_ip)
    print("   => Testing whether cluster can be reached")
    if not is_reachable(public_dns=public_ip):
        print("Cannot connect to remote cluster. Please check:")
        print("- whether port 2200 is open in cloud security group")
        print(
            "- whether VPN is enabled if you need one to connect to the cluster"
        )
        sys.exit(1)

if args.kernelspec or args.restart:
    print("   => Check installed libraries")
    status_file.log_check()
    if not check_installed(cluster_id):
        packages = json.loads(check_output(["conda", "list", "--json"]))
        deps = {
            p["name"]: p["version"]
            for p in packages
            if p["name"] in ["ipywidgets", "sidecar"]
        }

        print("\n* Installing databricks_jupyterlab, ipywidgets on remote driver")
        status_file.log_install_driver()
        install_libs(cluster_id,
                    module_path,
                    ipywidets_version=deps["ipywidgets"],
                    sidecar_version=deps["sidecar"])
    status_file.log_done()
    
if args.kernelspec:
    print("\n* Create remote kernel spec")
    create_kernelspec(profile, args.organisation, host, cluster_id,
                      cluster_name)

    print("\n* Setting global config of jupyter lab (autorestart, timeout)")
    write_config()
 
if args.versioncheck:
    version_check()

if args.sshfs:
    print("\n* Mount remote filesystem to ./remotefs/%s", cluster_id)
    mount_sshfs(cluster_id)

if args.profiles:
    show_profiles()

print("")
